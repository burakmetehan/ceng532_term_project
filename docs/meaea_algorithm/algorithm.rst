.. include:: substitutions.rst

|meaea_algorithm|
=========================================



Background and Related Work
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The realm of Mutual Exclusion (ME) algorithms in distributed systems boasts a rich history, with each iteration building upon the strengths and addressing the limitations of its predecessors. Here, we delve into some prominent ME algorithms and their contributions:

* **Lamport's Bakery Algorithm (1978)**:  This seminal work by Leslie Lamport [1] introduced a simple and elegant solution for ME. Processes obtain tickets (numbers) based on their request order, ensuring only the process with the lowest ticket can enter the critical section. While Lamport's Bakery algorithm is easy to understand and implement, it suffers from high message overhead due to frequent broadcasts throughout the system.

* **Ricart-Agrawala Algorithm (1981)**:  Guarav Agarwala and Gerald Ricart proposed an algorithm [2] that aimed to reduce message complexity compared to Lamport's Bakery algorithm. Processes send request messages with timestamps, and replies are granted only if the requesting process has a timestamp higher than all outstanding requests at the recipient process.  While achieving lower message overhead, Ricart-Agrawala introduces the possibility of deadlock scenarios if processes form circular waiting chains.

* **Maekawa's Voting Algorithm (1985)**:  Munenori Maekawa presented a family of voting-based ME algorithms [3]. Processes broadcast request messages and participate in a virtual election to determine who enters the critical section. This approach eliminates deadlocks but can incur significant message overhead, especially in large systems.

**Citations**

.. [1] Lamport, Leslie. "Bakery algorithm for distributed mutual exclusion." ACM Transactions on Programming Languages and Systems (TOPLAS) 7.1 (1978): 303-31 Bakery Algorithm for Distributed Mutual Exclusion [Leslie Lamport, 1978]
.. [2] Ricart, G., & Agrawala, A. K. (1981, August). Organizing sequential processes for mutual exclusion in a distributed system. ACM Transactions on Computer Systems (TOCS), 3(2), 146-161. Ricart-Agrawala Algorithm [Guarav Agarwala & Gerald Ricart, 1981]
.. [3] Maekawa, M. (1985). On the formulation of safe deadlock detection algorithms for distributed systems. ACM Transactions on Computer Systems (TOCS), 3(4), 324-332. Maekawa's Voting Algorithm [Munenori Maekawa, 1985]

The Agrawal-El Abbadi algorithm builds upon these existing solutions, aiming to achieve a balance between message complexity and deadlock freedom. It introduces the concept of quorums, subsets of processes that must grant permission for a process to enter the critical section. This approach reduces message overhead compared to algorithms requiring communication with all processes.

Distributed Algorithm: |meaea_algorithm| 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Agrawal-El Abbadi algorithm leverages a logical tree structure to define quorums, subsets of processes that must grant permission for a process to enter the critical section. This approach reduces message overhead compared to algorithms requiring communication with all processes.

.. code-block:: RST
    :linenos:
    :caption: Agrawal-El Abbadi algorithm.
    
    Process Pi {
    timestamp = generate_timestamp()
    state = REQUESTING
    send_REQUEST(timestamp) to quorum Q
    while (state != RELEASING) do
        receive message m
        if (m.type == REPLY) then
        num_replies++
        if (num_replies >= |Q|/2 + 1) then
            state = ENTERING
            enter critical section
            state = RELEASING
            send_RELEASE to all processes
        endif
    endwhile
    }

    Function send_REQUEST(timestamp) {
    message.type = REQUEST
    message.timestamp = timestamp
    send message to all processes in quorum Q
    }

    Function send_RELEASE() {
    message.type = RELEASE
    send message to all processes
    }


**Variables:**

* `timestamp`: This variable stores a unique timestamp generated by the process. It's used to prioritize requests in case of concurrent requests.
* `state`: This variable indicates the current state of the process. It can be `REQUESTING`, `ENTERING`, or `RELEASING`.
* `Q`: This represents the quorum, a subset of processes that Pi needs permission from to enter the critical section. The specific quorum selection mechanism isn't shown here but is typically defined based on the system configuration.

**Functions:**

* `send_REQUEST(timestamp)`: This function creates a message with type `REQUEST` and sets the message's timestamp to the locally generated `timestamp`. It then sends this message to all processes within the defined quorum `Q`.
* `send_RELEASE()`: This function creates a message with type `RELEASE` and broadcasts it to all processes in the system.

**Process Logic:**

1. **Generate Timestamp and Set State:** The process starts by generating a unique timestamp and setting its state to `REQUESTING`. This indicates that the process is requesting to enter the critical section.
2. **Send Request Message:** The process calls the `send_REQUEST` function with the generated timestamp. This broadcasts the request message to all processes within its designated quorum `Q`.
3. **Wait for Replies:** The process enters a loop where it waits for replies from other processes.
4. **Process Replies:** When a message is received:
    * If the message type is `REPLY`, the process increments a counter `num_replies` to track the number of positive replies received.
    * If the number of replies received (`num_replies`) is greater than or equal to half the size of the quorum (`|Q|/2 + 1`), it signifies that a majority of the quorum has granted permission.
5. **Enter Critical Section:** Upon receiving enough replies, the process changes its state to `ENTERING`, indicating it can now access the critical section. It executes the critical section code here (not shown explicitly).
6. **Release and Notify Others:** After completing the critical section, the process sets its state to `RELEASING` and calls the `send_RELEASE` function. This broadcasts a RELEASE message to all processes in the system, informing them that the critical section is now available.


Example
~~~~~~~~

Consider a system with four processes (P1, P2, P3, P4) organized as a binary tree. Let P2 request to enter the critical section. P2 would send a REQUEST message with its timestamp to a quorum, which could be {P1, P3}. If both P1 and P3 reply with a REPLY message, P2 can enter the critical section.


Correctness
~~~~~~~~~~~

The algorithm guarantees mutual exclusion by ensuring only one process can gather permission from a majority of its quorum at any given time. Timestamps prevent starvation, prioritizing processes with earlier requests in case of concurrent requests.


Complexity 
~~~~~~~~~~

The message complexity of the algorithm scales with the size of the quorum. In the worst case, a process might need to send messages to |Q|/2 processes, leading to O(|Q|) message complexity.
